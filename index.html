<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro Stickman Cricket: Realistic + Colors + Variations</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Arial', sans-serif; }
        canvas { box-shadow: 0 0 20px rgba(255,255,255,0.2); border-radius: 4px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>

<script>
// --- CONFIGURATION ---
const ALL_TEAMS = ['Nepal', 'India', 'Australia', 'England', 'Pakistan', 'South Africa', 'West Indies', 'Sri Lanka'];
const TOTAL_OVERS = 6;
const GAME_WIDTH = 360;
const GAME_HEIGHT = 640;

// ========== TEAM COLORS ==========
const TEAM_COLORS = {
    'Nepal': 0x003893,      // blue
    'India': 0x1F77B4,      // ocean blue
    'Australia': 0xFFD700,  // gold
    'England': 0xCE1124,    // red
    'Pakistan': 0x1D5E3F,   // green
    'South Africa': 0xF1C40F, // yellow
    'West Indies': 0x800080, // purple
    'Sri Lanka': 0x000080   // navy
};

const config = {
    type: Phaser.AUTO,
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: GAME_WIDTH,
        height: GAME_HEIGHT
    },
    backgroundColor: '#388E3C',
    scene: { preload, create, update }
};

const game = new Phaser.Game(config);

// --- STATE VARIABLES ---
let gameState = 'MAIN_MENU';
let gameMode = 'QUICK';

let playerTeam = null;
let opponentTeam = null;
let battingTeam, bowlingTeam;
let currentInnings = 1;

// Tournament
let tournamentRound = 0;
const ROUND_NAMES = ["QUARTER FINAL", "SEMI FINAL", "FINAL"];
let tournamentTeams = []; 

// Match Stats
let score = 0, wickets = 0, legalBallsInOver = 0, totalOversBowled = 0;
let targetScore = 0;
let overHistory = []; 

// Colors
const COLOR_FIELDING = 0xFF5252;
const COLOR_BATTING = 0xFFFFFF;  
const COLOR_SKIN = 0xE0AC69;

// Objects
let bowler, batsmanGroup, bat, ball;
let wicketKeeper;
let fielders = [];
let textScore, textStatus, textOver, textTarget;
let currentMenuContainer;

// ========== NEW: ball shadow, left‑hand/left‑arm flags ==========
let ballShadow;
let isLeftHandedBatsman = false;
let isLeftArmBowler = false;

function preload() {}

function create() {
    // --- 1. FIELD ---
    this.add.circle(GAME_WIDTH/2, GAME_HEIGHT/2, 300, 0x4CAF50);
    this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, 60, 320, 0xE6D7B5);

    let bowlCreaseY = GAME_HEIGHT/2 - 140;
    let batCreaseY = GAME_HEIGHT/2 + 140;
    
    this.add.rectangle(GAME_WIDTH/2, bowlCreaseY, 60, 2, 0xFFFFFF); 
    this.add.rectangle(GAME_WIDTH/2, bowlCreaseY - 5, 15, 5, 0xFFFFFF); 
    this.add.rectangle(GAME_WIDTH/2, batCreaseY, 60, 2, 0xFFFFFF); 
    this.add.rectangle(GAME_WIDTH/2, batCreaseY + 5, 15, 5, 0xFFFFFF);

    // --- 2. PLAYERS ---
    wicketKeeper = createStickman(this, GAME_WIDTH/2, batCreaseY + 50, COLOR_FIELDING); 
    wicketKeeper.setScale(0.9);

    let fPos = [{x:-140, y:80}, {x:140, y:60}, {x:120, y:-50}, {x:-130, y:-50}];
    fielders = [];
    fPos.forEach(p => {
        let f = createStickman(this, GAME_WIDTH/2 + p.x, GAME_HEIGHT/2 + p.y, COLOR_FIELDING);
        f.setScale(0.8);
        fielders.push(f);
    });

    bowler = createStickman(this, GAME_WIDTH/2, 50, COLOR_FIELDING);
    batsmanGroup = this.add.container(GAME_WIDTH/2 - 10, batCreaseY - 40);
    createBatsmanGraphics(this, batsmanGroup);
    
    // ========== ball + shadow ==========
    ball = this.add.circle(0, 0, 6, 0xFFFFFF);
    ballShadow = this.add.circle(0, 0, 7, 0x222222, 0.5);
    ball.visible = false;
    ballShadow.visible = false;

    // --- 3. UI ---
    createUI(this);
    
    // ========== wicketkeeper idle movement ==========
    startWicketKeeperMovement(this);
    
    showMainMenu(this);
}

function update() {}

// ========== APPLY TEAM COLORS TO FIELDERS ==========
function setTeamColors(scene, teamName) {
    let color = TEAM_COLORS[teamName] || COLOR_FIELDING;
    const recolorStickman = (container) => {
        container.each((child) => {
            if (child.type === 'Rectangle') child.setFillStyle(color);
        });
    };
    recolorStickman(bowler);
    recolorStickman(wicketKeeper);
    fielders.forEach(f => recolorStickman(f));
}

// ========== APPLY BATTING TEAM COLOR TO BATSMAN ==========
function setBatsmanTeamColor(scene, teamName) {
    let color = TEAM_COLORS[teamName] || COLOR_BATTING; // fallback white
    // recolor the body rectangles (shirt, pants) inside batsmanGroup
    batsmanGroup.each((child) => {
        if (child.type === 'Rectangle' && child !== bat) { // exclude the bat
            child.setFillStyle(color);
        }
    });
}

// ========== WICKETKEEPER IDLE MOVEMENT ==========
function startWicketKeeperMovement(scene) {
    scene.time.addEvent({
        delay: 1800,
        callback: () => {
            if (wicketKeeper && wicketKeeper.active) {
                let shift = Phaser.Math.Between(-12, 12);
                scene.tweens.add({
                    targets: wicketKeeper,
                    x: GAME_WIDTH/2 + shift,
                    duration: 600,
                    yoyo: true,
                    ease: 'Sine.easeInOut'
                });
            }
        },
        loop: true
    });
}

// ========== BOUNDARY ANIMATION (four/six) ==========
function showBoundaryAnimation(scene, x, y, runs) {
    let boundaryText = scene.add.text(x, y, runs === 4 ? 'FOUR!' : 'SIX!', {
        fontSize: '28px', fontStyle: 'bold', color: '#FFD700',
        stroke: '#000', strokeThickness: 4
    }).setOrigin(0.5);
    boundaryText.setDepth(80);
    let ring = scene.add.circle(x, y, 12, 0xFFD700, 0.7);
    ring.setDepth(79);
    scene.tweens.add({
        targets: [boundaryText, ring],
        scale: 2.5,
        alpha: 0,
        duration: 600,
        onComplete: () => {
            boundaryText.destroy();
            ring.destroy();
        }
    });
}

// ========== GAME LOGIC ==========
function startMatch(scene) {
    if(currentMenuContainer) currentMenuContainer.destroy();
    
    score = 0; wickets = 0; legalBallsInOver = 0; totalOversBowled = 0;
    targetScore = 0; overHistory = []; currentInnings = 1;
    
    battingTeam = playerTeam;
    bowlingTeam = opponentTeam;
    
    // ===== set colors =====
    setTeamColors(scene, bowlingTeam);
    setBatsmanTeamColor(scene, battingTeam);
    
    // ===== random left/right variations (20%) =====
    isLeftHandedBatsman = Math.random() < 0.2;
    isLeftArmBowler = Math.random() < 0.2;
    applyBatsmanStance(scene);
    applyBowlerStance(scene);
    
    updateScoreboard();
    
    let msg = gameMode === 'TOURNAMENT' ? `${ROUND_NAMES[tournamentRound]}\nVS ${opponentTeam}` : "MATCH START!";
    textStatus.setText(msg).setAlpha(1);
    scene.time.delayedCall(2000, () => {
        textStatus.setAlpha(0);
        startNewOver(scene);
    });
}

// ===== apply left/right batsman =====
function applyBatsmanStance(scene) {
    // reposition bat: left handed → bat on left side, negative rotation
    if (isLeftHandedBatsman) {
        bat.x = -8;        // left side
        bat.rotation = 0.5; // mirror? actually we want negative for lefty
        bat.rotation = -0.5;
        bat.setOrigin(0.5, 0);
    } else {
        bat.x = 8;
        bat.rotation = 0.5;
    }
}

// ===== apply left/right bowler stance (bowls from left side) =====
function applyBowlerStance(scene) {
    if (isLeftArmBowler) {
        bowler.x = GAME_WIDTH/2 - 30; // left side of crease
    } else {
        bowler.x = GAME_WIDTH/2;
    }
}

function startNewOver(scene) {
    legalBallsInOver = 0; overHistory = [];
    textOver.setText("THIS OVER: ");
    textStatus.setText("NEW OVER").setAlpha(1);
    scene.tweens.add({ targets: textStatus, alpha: 0, duration: 1000, delay: 1000 });
    scene.time.delayedCall(2000, () => nextBall(scene));
}

function nextBall(scene) {
    if (wickets >= 6 || totalOversBowled >= TOTAL_OVERS) { endInnings(scene); return; }
    if (currentInnings === 2 && score > targetScore) { endInnings(scene); return; }
    
    bowler.y = 40; 
    // run-up animation
    scene.tweens.add({
        targets: bowler, y: GAME_HEIGHT/2 - 150, duration: 800,
        onComplete: () => {
            // release ball – use bowler.x for left/right variation
            ball.x = bowler.x;
            ball.y = GAME_HEIGHT/2 - 150; 
            ball.visible = true;
            ballShadow.visible = true;
            ballShadow.x = ball.x + 4; ballShadow.y = ball.y + 6;
            
            let isWide = Math.random() < 0.1;
            let tx = isWide ? (bowler.x + (Math.random() < 0.5 ? -70 : 70)) : GAME_WIDTH/2;
            
            scene.tweens.add({
                targets: [ball, ballShadow],
                x: tx, y: GAME_HEIGHT/2 + 140, duration: 600,
                onUpdate: () => {
                    ballShadow.x = ball.x + 4;
                    ballShadow.y = ball.y + 6;
                },
                onComplete: () => {
                    if(isWide) handleWide(scene);
                    else handleHit(scene);
                }
            });
        }
    });
}

function handleWide(scene) {
    scene.tweens.add({
        targets: [ball, ballShadow], y: GAME_HEIGHT/2 + 180, duration: 200,
        onUpdate: () => { ballShadow.x = ball.x + 4; ballShadow.y = ball.y + 6; },
        onComplete: () => {
            ball.visible = false; ballShadow.visible = false; bowler.y = 40;
            score++; overHistory.push("WD");
            textStatus.setText("WIDE").setColor('#FFA500').setAlpha(1);
            updateScoreboard();
            textOver.setText("THIS OVER: " + overHistory.join(" "));
            scene.time.delayedCall(1500, () => { textStatus.setAlpha(0); nextBall(scene); });
        }
    });
}

// ========== HANDLE HIT (with fixed over notation and boundary animation) ==========
function handleHit(scene) {
    scene.tweens.add({ targets: bat, rotation: isLeftHandedBatsman ? 0.5 : -2.0, duration: 100, yoyo: true });
    
    let outcome = Math.random();
    let runs = 0, txt = "0", isOut = false, type = "";
    
    if(outcome < 0.1) {          // 10% out
        isOut = true;
    } else if(outcome < 0.2) {   // 10% dot
        runs = 0; txt = "0";
    } else if(outcome < 0.45) {  // 25% 1
        runs = 1; txt = "1";
    } else if(outcome < 0.65) {  // 20% 2
        runs = 2; txt = "2";
    } else if(outcome < 0.85) {  // 20% FOUR
        runs = 4; txt = "4";
    } else {                    // 15% SIX
        runs = 6; txt = "6";
    }
    
    let tx, ty;
    
    if(isOut) {
        txt = "W";
        if(Math.random() > 0.5) {
            type = "CAUGHT!";
            if(Math.random() < 0.4) {
                tx = wicketKeeper.x;
                ty = wicketKeeper.y - 10;
            } else {
                let f = fielders[Math.floor(Math.random()*fielders.length)];
                tx = f.x;
                ty = f.y - 5;
            }
        } else {
            type = "BOWLED!";
            tx = GAME_WIDTH/2;
            ty = GAME_HEIGHT/2 + 160;
        }
    } else {
        if(runs === 0) {
            let f = fielders[Math.floor(Math.random()*fielders.length)];
            tx = f.x;
            ty = f.y - 5;
        } else if(runs === 1 || runs === 2) {
            tx = Phaser.Math.Between(GAME_WIDTH/2 - 100, GAME_WIDTH/2 + 100);
            ty = Phaser.Math.Between(GAME_HEIGHT/2 - 80, GAME_HEIGHT/2 + 80);
        } else if(runs === 4) {
            let side = Math.random() < 0.5 ? -1 : 1;
            tx = GAME_WIDTH/2 + side * 130;
            ty = Phaser.Math.Between(GAME_HEIGHT/2 - 100, GAME_HEIGHT/2 + 150);
        } else { // 6 runs
            tx = GAME_WIDTH/2;
            ty = -60;
        }
    }
    
    scene.tweens.add({
        targets: [ball, ballShadow],
        x: tx, y: ty, duration: isOut ? 400 : 700,
        onUpdate: () => { ballShadow.x = ball.x + 4; ballShadow.y = ball.y + 6; },
        onComplete: () => {
            ball.visible = false; ballShadow.visible = false; bowler.y = 40;
            
            // ===== FIX OVER NOTATION: increment totalOversBowled immediately when over completes =====
            let overCompleted = false;
            if(!isOut) {
                legalBallsInOver++;
                if(legalBallsInOver === 6) {
                    totalOversBowled++;
                    legalBallsInOver = 0;
                    overCompleted = true;
                }
            }
            
            if(!isOut) score += runs;
            else wickets++;
            
            if(!isOut) overHistory.push(txt);
            else overHistory.push("W");
            
            // ===== BOUNDARY ANIMATION for 4 or 6 =====
            if(runs === 4 || runs === 6) {
                showBoundaryAnimation(scene, tx, ty, runs);
            }
            
            textOver.setText("THIS OVER: " + overHistory.join(" "));
            textStatus.setText(isOut ? type : txt + " RUNS").setColor(isOut?'#ff0000':'#fff').setAlpha(1);
            updateScoreboard();
            
            scene.time.delayedCall(1500, () => {
                textStatus.setAlpha(0);
                if(overCompleted) {
                    startNewOver(scene);
                } else {
                    nextBall(scene);
                }
            });
        }
    });
}

function endInnings(scene) {
    if(currentInnings === 1) {
        currentInnings = 2; targetScore = score + 1;
        let temp = battingTeam; battingTeam = bowlingTeam; bowlingTeam = temp;
        
        // ===== update colors for new innings =====
        setTeamColors(scene, bowlingTeam);
        setBatsmanTeamColor(scene, battingTeam);
        
        // ===== new random left/right for 2nd innings (20% chance) =====
        isLeftHandedBatsman = Math.random() < 0.2;
        isLeftArmBowler = Math.random() < 0.2;
        applyBatsmanStance(scene);
        applyBowlerStance(scene);
        
        score=0; wickets=0; legalBallsInOver=0; totalOversBowled=0; overHistory=[];
        textStatus.setText(`TARGET: ${targetScore}`).setAlpha(1);
        scene.input.once('pointerdown', () => { textStatus.setAlpha(0); startNewOver(scene); });
    } else {
        let won = score < targetScore;
        let result = won ? `${bowlingTeam} WON!` : `${battingTeam} WON!`;
        textStatus.setText(result).setAlpha(1);
        scene.input.once('pointerdown', () => {
            textStatus.setAlpha(0);
            if(gameMode === 'TOURNAMENT') handleTournamentProgress(scene, won);
            else showMainMenu(scene);
        });
    }
}

function handleTournamentProgress(scene, playerWon) {
    if(!playerWon) showTournamentLoss(scene);
    else {
        let nextRoundTeams = [playerTeam];
        let needed = (tournamentTeams.length / 2) - 1;
        let others = tournamentTeams.filter(t => t !== playerTeam && t !== opponentTeam);
        others.sort(() => Math.random() - 0.5);
        for(let i=0; i<needed; i++) nextRoundTeams.push(others[i]);
        tournamentTeams = nextRoundTeams;
        tournamentRound++;
        if(tournamentRound > 2) showTournamentWin(scene);
        else showTournamentBracket(scene);
    }
}

function updateScoreboard() {
    // Display overs in proper cricket format (1.0, 2.0 etc.)
    let oversDisplay = totalOversBowled + (legalBallsInOver > 0 ? '.' + legalBallsInOver : '');
    let title = currentInnings === 1 ? "1st Innings" : `Target: ${targetScore}`;
    textScore.setText(`${battingTeam}: ${score}/${wickets} (${oversDisplay})`);
    textTarget.setText(title);
}

// ========== UI & MENUS ==========
function showMainMenu(scene) {
    if(currentMenuContainer) currentMenuContainer.destroy();
    let bg = scene.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.85);
    bg.setInteractive();
    let title = scene.add.text(GAME_WIDTH/2, 120, "STICK CRICKET\nTOURNAMENT", { fontSize: '32px', color: '#4CAF50', fontStyle: 'bold', align: 'center' }).setOrigin(0.5);
    let btnQuick = createButton(scene, GAME_WIDTH/2, 300, "QUICK MATCH", () => { gameMode = 'QUICK'; showTeamSelection(scene); });
    let btnTourney = createButton(scene, GAME_WIDTH/2, 380, "TOURNAMENT", () => { gameMode = 'TOURNAMENT'; tournamentRound = 0; tournamentTeams = [...ALL_TEAMS].sort(() => Math.random() - 0.5); showTeamSelection(scene); });
    currentMenuContainer = scene.add.container(0, 0, [bg, title, btnQuick, btnTourney]);
    currentMenuContainer.setDepth(100);
}

function showTeamSelection(scene) {
    if(currentMenuContainer) currentMenuContainer.destroy();
    let bg = scene.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.9);
    bg.setInteractive();
    let txt = gameMode === 'TOURNAMENT' ? "SELECT YOUR TEAM" : "SELECT TEAM 1";
    let title = scene.add.text(GAME_WIDTH/2, 80, txt, { fontSize: '24px', color: '#fff', fontStyle: 'bold' }).setOrigin(0.5);
    let container = scene.add.container(0, 0, [bg, title]);
    let y = 140;
    ALL_TEAMS.forEach(team => {
        let btn = scene.add.text(GAME_WIDTH/2, y, team, { fontSize: '18px', backgroundColor: '#222', padding: {x:40, y:10}, fixedWidth: 240, align: 'center', color: '#fff', stroke: '#4CAF50', strokeThickness: 2 }).setOrigin(0.5).setInteractive();
        btn.on('pointerdown', () => {
            playerTeam = team;
            if(gameMode === 'TOURNAMENT') showTournamentBracket(scene);
            else {
                if(!opponentTeam) {
                    title.setText("SELECT OPPONENT");
                    let ops = ALL_TEAMS.filter(t => t !== playerTeam);
                    opponentTeam = ops[Math.floor(Math.random()*ops.length)];
                    startMatch(scene);
                }
            }
        });
        container.add(btn);
        y += 50;
    });
    container.setDepth(100);
    currentMenuContainer = container;
}

function showTournamentBracket(scene) {
    if(currentMenuContainer) currentMenuContainer.destroy();
    let bg = scene.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.95);
    bg.setInteractive();
    let title = scene.add.text(GAME_WIDTH/2, 60, ROUND_NAMES[tournamentRound], { fontSize: '28px', color: '#FFD700' }).setOrigin(0.5);
    let container = scene.add.container(0, 0, [bg, title]);
    let y = 150;
    if(!tournamentTeams.includes(playerTeam)) tournamentTeams[0] = playerTeam;
    for(let i=0; i<tournamentTeams.length; i+=2) {
        let t1 = tournamentTeams[i];
        let t2 = tournamentTeams[i+1] || "Bye";
        let isMyMatch = (t1 === playerTeam || t2 === playerTeam);
        let color = isMyMatch ? '#4CAF50' : '#888';
        let matchTxt = scene.add.text(GAME_WIDTH/2, y, `${t1} vs ${t2}`, { fontSize: '20px', color: color }).setOrigin(0.5);
        container.add(matchTxt);
        if(isMyMatch) {
            opponentTeam = (t1 === playerTeam) ? t2 : t1;
            let playBtn = createButton(scene, GAME_WIDTH/2, y+35, "PLAY MATCH", () => startMatch(scene));
            container.add(playBtn);
        }
        y += 90;
    }
    container.setDepth(100);
    currentMenuContainer = container;
}

function showTournamentWin(scene) {
    if(currentMenuContainer) currentMenuContainer.destroy();
    let bg = scene.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.9);
    let t1 = scene.add.text(GAME_WIDTH/2, 200, "CHAMPION!", { fontSize: '40px', color: '#FFD700' }).setOrigin(0.5);
    let t2 = scene.add.text(GAME_WIDTH/2, 260, playerTeam, { fontSize: '30px', color: '#fff' }).setOrigin(0.5);
    let btn = createButton(scene, GAME_WIDTH/2, 400, "MENU", () => showMainMenu(scene));
    currentMenuContainer = scene.add.container(0,0,[bg,t1,t2,btn]);
    currentMenuContainer.setDepth(100);
}

function showTournamentLoss(scene) {
    if(currentMenuContainer) currentMenuContainer.destroy();
    let bg = scene.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.9);
    let t1 = scene.add.text(GAME_WIDTH/2, 200, "ELIMINATED", { fontSize: '35px', color: '#F44336' }).setOrigin(0.5);
    let btn = createButton(scene, GAME_WIDTH/2, 400, "MENU", () => showMainMenu(scene));
    currentMenuContainer = scene.add.container(0,0,[bg,t1,btn]);
    currentMenuContainer.setDepth(100);
}

function createButton(scene, x, y, text, cb) {
    let btn = scene.add.text(x, y, text, { fontSize: '20px', backgroundColor: '#333', padding: {x:20, y:10}, color: '#fff', stroke: '#fff', strokeThickness: 1 }).setOrigin(0.5).setInteractive();
    if(cb) btn.on('pointerdown', cb);
    return btn;
}

function createUI(scene) {
    textScore = scene.add.text(10, 10, '', { fontSize: '20px', fontStyle: 'bold' });
    textTarget = scene.add.text(GAME_WIDTH-10, 10, '', { fontSize: '16px', color:'#FFD700' }).setOrigin(1,0);
    textStatus = scene.add.text(GAME_WIDTH/2, GAME_HEIGHT/2, '', { fontSize: '30px', fontStyle: 'bold', align:'center', stroke:'#000', strokeThickness:4 }).setOrigin(0.5);
    textOver = scene.add.text(GAME_WIDTH/2, GAME_HEIGHT-30, '', { fontSize: '16px', color:'#0f0' }).setOrigin(0.5);
    textScore.setDepth(50); textTarget.setDepth(50); textStatus.setDepth(50); textOver.setDepth(50);
}

function createStickman(scene, x, y, color) {
    let c = scene.add.container(x, y);
    c.add([
        scene.add.circle(0,0,6,COLOR_SKIN),
        scene.add.rectangle(0,12,3,20,color),
        scene.add.rectangle(0,8,18,3,color),
        scene.add.rectangle(-3,24,3,12,color),
        scene.add.rectangle(3,24,3,12,color)
    ]);
    return c;
}

function createBatsmanGraphics(scene, container) {
    bat = scene.add.rectangle(8,10,6,28,0x8D6E63).setOrigin(0.5,0);
    bat.rotation = 0.5;
    container.add([
        scene.add.circle(0,0,5,COLOR_SKIN),
        scene.add.rectangle(0,10,3,18,COLOR_BATTING),
        scene.add.rectangle(-3,22,2,10,COLOR_BATTING),
        scene.add.rectangle(3,22,2,10,COLOR_BATTING),
        bat
    ]);
}
</script>
</body>
</html>
