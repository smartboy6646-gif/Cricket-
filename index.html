<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ULTIMATE 3D CRICKET - CUTE & AUDIO READY</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; color: white; user-select: none; }
        
        #hud { position: absolute; top: 15px; left: 15px; right: 15px; display: flex; justify-content: space-between; pointer-events: none; z-index: 100; }
        .score-panel { background: linear-gradient(90deg, #003300, #000); padding: 8px 20px; border-radius: 5px; border-left: 5px solid #ffd700; font-size: 18px; font-weight: 800; color: #fff; text-transform: uppercase; box-shadow: 0 4px 6px rgba(0,0,0,0.5); }
        #target-info { background: linear-gradient(90deg, #000, #440000); padding: 8px 20px; border-radius: 5px; border-right: 5px solid #ffd700; font-size: 18px; font-weight: 800; color: #ffd966; box-shadow: 0 4px 6px rgba(0,0,0,0.5); }
        
        #status { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 55px; font-weight: 900; color: #fff; text-shadow: 0 0 20px #ff0000, 0 0 10px #000; display: none; z-index: 200; text-align: center; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        #ball-tracker { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; pointer-events: none; }
        .ball-bubble { width: 35px; height: 35px; border-radius: 50%; background: rgba(0,0,0,0.8); border: 2px solid #555; display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 16px; color: white; }
        .b-4 { background: #1976D2; border-color: #4fc3f7; }
        .b-6 { background: #388E3C; border-color: #81c784; }
        .b-w { background: #d32f2f; border-color: #e57373; }
        .b-wd { background: #F57C00; border-color: #ffb74d; font-size: 12px; }

        #menu-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, #0a2a0a, #000); display: flex; justify-content: center; align-items: center; z-index: 1000; overflow-y: auto; }
        .glass-panel { background: rgba(15, 15, 15, 0.95); padding: 30px; border-radius: 15px; border: 2px solid #4CAF50; box-shadow: 0 0 50px rgba(76, 175, 80, 0.3); width: 90%; max-width: 500px; text-align: center; margin: auto; }
        .menu-title { font-size: 28px; color: #ffd700; margin-bottom: 20px; font-weight: 900; }
        .menu-btn { background: linear-gradient(45deg, #1e4a1e, #112a11); color: white; font-size: 18px; padding: 12px; margin: 10px 0; border: 1px solid #66cc66; border-radius: 8px; cursor: pointer; font-weight: bold; width: 100%; transition: 0.2s; }
        .menu-btn:hover { background: #4CAF50; color: black; transform: scale(1.02); }
        .team-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .team-btn { background: #222; color: white; padding: 12px; border: 1px solid #555; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .team-btn:hover { background: #ffd700; color: black; }
        .bracket-row { display: flex; justify-content: space-between; align-items: center; background: #2a2a2a; margin: 8px 0; padding: 12px; border-radius: 5px; border-left: 4px solid #555; }
        .my-match { border-left-color: #ffd700; background: #3a3a3a; }
        .action-btn { border: none; padding: 6px 12px; cursor: pointer; border-radius: 4px; font-weight: bold; margin-left: 5px; }
        .btn-play { background: gold; color: black; }
        .btn-watch { background: #2196F3; color: white; }
        .btn-sim { background: #757575; color: white; }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0); } to { transform: translate(-50%, -50%) scale(1); } }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="hud"><div id="scorecard" class="score-panel">0/0 (0.0)</div><div id="target-info">1st Innings</div></div>
    <div id="status"></div><div id="ball-tracker"></div><div id="menu-container"></div>

    <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.128.0/build/three.module.js","three/addons/":"https://unpkg.com/three@0.128.0/examples/jsm/","gsap":"https://unpkg.com/gsap@3.12.5/index.js"}}</script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import gsap from 'gsap';

        // --- AUDIO SETUP (‡§§‡§™‡§æ‡§à‡§Ç‡§≤‡•á ‡§Ø‡§π‡§æ‡§Å ‡§™‡§õ‡§ø ‡§Ü‡§´‡•ç‡§®‡•ã ‡§Ö‡§°‡§ø‡§Ø‡•ã ‡§≤‡§ø‡§ô‡•ç‡§ï ‡§π‡§æ‡§≤‡•ç‡§® ‡§∏‡§ï‡•ç‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ) ---
        const sounds = {
            bowl: null, // e.g., new Audio('bowl_sound.mp3')
            hit: null,  // e.g., new Audio('bat_hit.mp3')
            cheer: null // e.g., new Audio('crowd_cheer.mp3')
        };
        function playSound(type) {
            if(sounds[type]) {
                sounds[type].currentTime = 0;
                sounds[type].play().catch(e => console.log("Audio not ready"));
            }
        }

        // --- CONFIG ---
        const TEAMS = ['Nepal', 'India', 'Australia', 'England', 'Pakistan', 'South Africa', 'West Indies', 'Sri Lanka'];
        const TEAM_COLORS = { 'Nepal': 0x003893, 'India': 0x1F77B4, 'Australia': 0xFFD700, 'England': 0xCE1124, 'Pakistan': 0x1D5E3F, 'South Africa': 0xF1C40F, 'West Indies': 0x800080, 'Sri Lanka': 0x000080 };
        const TOTAL_OVERS = 3, MAX_WICKETS = 6, BOUNDARY_RADIUS = 60;

        // --- GLOBALS ---
        let scene, camera, renderer, controls;
        let bowler, striker, nonStriker, keeper, ball, ballShadow;
        let stumpsBowling, stumpsBatting, fielders = [], allPlayers = [];
        let gameMode = 'QUICK', playerTeam = 'Nepal', opponentTeam = 'India', battingTeamStr = '', bowlingTeamStr = '';
        let score = 0, wickets = 0, balls = 0, overs = 0, target = 0, innings = 1;
        let currentOverLog = [], isBallInPlay = false, camState = 'STATIC', deliveryTimer;
        let tournamentRound = 0, tournamentBracket = [], isWatchMode = false, currentTournMatchIdx = 0;
        
        // --- INIT THREE.JS ---
        function initScene() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a0f18); scene.fog = new THREE.Fog(0x0a0f18, 120, 600);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.maxPolarAngle = Math.PI/2 - 0.02; controls.maxDistance = 150;

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(50, 80, -50); sun.castShadow = true;
            sun.shadow.camera.left = -80; sun.shadow.camera.right = 80; sun.shadow.camera.top = 80; sun.shadow.camera.bottom = -80;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048; scene.add(sun);
            scene.add(new THREE.HemisphereLight(0xaaccff, 0x112211, 0.3));

            const ground = new THREE.Mesh(new THREE.CircleGeometry(90, 64), new THREE.MeshStandardMaterial({ color: 0x245e24, roughness: 0.9 })); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
            const pitch = new THREE.Mesh(new THREE.BoxGeometry(3.6, 0.05, 22), new THREE.MeshStandardMaterial({ color: 0xc4a473 })); pitch.receiveShadow = true; pitch.position.y = 0.03; scene.add(pitch);
            
            // --- PITCH LINES (CREASE) FIX ---
            const lineMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const creaseBat = new THREE.Mesh(new THREE.PlaneGeometry(3.6, 0.1), lineMat);
            creaseBat.rotation.x = -Math.PI/2; creaseBat.position.set(0, 0.06, 8.8); scene.add(creaseBat); // Batting Crease
            
            const creaseBowl = new THREE.Mesh(new THREE.PlaneGeometry(3.6, 0.1), lineMat);
            creaseBowl.rotation.x = -Math.PI/2; creaseBowl.position.set(0, 0.06, -8.8); scene.add(creaseBowl); // Bowling Crease

            // Boundary
            const rope = new THREE.Mesh(new THREE.TorusGeometry(BOUNDARY_RADIUS, 0.3, 8, 100), new THREE.MeshStandardMaterial({ color: 0xffffff })); rope.rotation.x = -Math.PI/2; scene.add(rope);

            const stadiumGroup = new THREE.Group();
            for (let i = 0; i < 3; i++) {
                const stand = new THREE.Mesh(new THREE.CylinderGeometry(BOUNDARY_RADIUS + 5 + i * 5, BOUNDARY_RADIUS + 2 + i * 5, 3 + i * 2, 64, 1, true), new THREE.MeshStandardMaterial({ color: i % 2 === 0 ? 0x1a365d : 0x7f1d1d, side: THREE.DoubleSide }));
                stand.position.y = 1.5 + i * 2.5; stadiumGroup.add(stand);
            }
            const fanGeo = new THREE.BufferGeometry(); const fanPos = [], fanCol = [];
            for (let i = 0; i < 4000; i++) {
                const a = Math.random() * Math.PI * 2, r = BOUNDARY_RADIUS + 3 + Math.random() * 15;
                fanPos.push(Math.cos(a) * r, (r - BOUNDARY_RADIUS) * 0.6 + Math.random() * 2, Math.sin(a) * r);
                fanCol.push(Math.random(), Math.random(), Math.random());
            }
            fanGeo.setAttribute('position', new THREE.Float32BufferAttribute(fanPos, 3)); fanGeo.setAttribute('color', new THREE.Float32BufferAttribute(fanCol, 3));
            stadiumGroup.add(new THREE.Points(fanGeo, new THREE.PointsMaterial({ size: 0.6, vertexColors: true }))); scene.add(stadiumGroup);
            
            stumpsBowling = createStumps(0, -10); stumpsBatting = createStumps(0, 10); scene.add(stumpsBowling); scene.add(stumpsBatting);
            
            ball = new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.4 })); ball.visible = false; scene.add(ball);
            ballShadow = new THREE.Mesh(new THREE.CircleGeometry(0.25), new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5 })); ballShadow.rotation.x = -Math.PI/2; ballShadow.visible = false; scene.add(ballShadow);
            
            resetCameraStatic(); animate();
        }

        // Taller & WIDER Stumps Fix
        function createStumps(x, z) {
            const g = new THREE.Group(); g.position.set(x, 0, z);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaa8800, emissiveIntensity: 0.3 });
            // Width slightly increased (spacing 0.15 instead of 0.12, radius 0.035)
            [-0.15, 0, 0.15].forEach(xx => {
                const s = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 0.95), mat); s.position.set(xx, 0.47, 0); g.add(s);
            });
            // Add Bails
            const bailMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const b1 = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.15), bailMat); b1.rotation.z = Math.PI/2; b1.position.set(-0.075, 0.96, 0); g.add(b1);
            const b2 = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.15), bailMat); b2.rotation.z = Math.PI/2; b2.position.set(0.075, 0.96, 0); g.add(b2);
            return g;
        }

        function resetCameraStatic() { camState = 'STATIC'; gsap.to(camera.position, { x: 0, y: 12, z: -25, duration: 1 }); controls.target.set(0, 1, 8); }

        // --- CUTE PLAYER CREATION (Caps & Eyes) ---
        function createPlayer(teamName, role) {
            const color = TEAM_COLORS[teamName] || 0xffffff, group = new THREE.Group();
            const kitMat = new THREE.MeshStandardMaterial({ color: color }), skinMat = new THREE.MeshStandardMaterial({ color: 0xd2a679 });
            
            const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.9), new THREE.MeshStandardMaterial({color: 0x111})); legL.position.set(-0.15, 0.45, 0);
            const legR = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.9), new THREE.MeshStandardMaterial({color: 0x111})); legR.position.set(0.15, 0.45, 0);
            group.add(legL); group.add(legR); group.userData.legs = [legL, legR];

            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.65, 0.25), kitMat); torso.position.y = 1.25; group.add(torso);
            
            // Cuter Head (Slightly larger sphere)
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25), skinMat); head.position.y = 1.78; 
            
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({color: 0x000000});
            const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.035), eyeMat); eyeR.position.set(0.08, 0.05, 0.22);
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.035), eyeMat); eyeL.position.set(-0.08, 0.05, 0.22);
            head.add(eyeR); head.add(eyeL);

            // Cap (Cute Team Hat)
            const capGroup = new THREE.Group();
            const capBase = new THREE.Mesh(new THREE.SphereGeometry(0.26, 16, 16, 0, Math.PI*2, 0, Math.PI/2), kitMat);
            const capBrim = new THREE.Mesh(new THREE.CylinderGeometry(0.26, 0.26, 0.05, 16, 1, false, 0, Math.PI), kitMat);
            capBrim.position.set(0, -0.05, 0.15); capBrim.scale.set(1, 1, 1.2);
            capGroup.add(capBase); capGroup.add(capBrim); capGroup.position.y = 0.05;
            head.add(capGroup); // Attach cap to head

            // Adjust head rotation based on role so they look at ball
            if (role === 'BOWL' || role === 'FIELD') { head.rotation.y = 0; }
            else if (role === 'BAT') { head.rotation.y = 1.5; } // Batsmen look sideways initially
            group.add(head);

            const shoulders = new THREE.Group(); shoulders.position.y = 1.5; group.add(shoulders); group.userData.shoulders = shoulders;
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.65, 0.12), kitMat); armL.position.set(-0.35, -0.3, 0);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.65, 0.12), kitMat); armR.position.set(0.35, -0.3, 0);
            shoulders.add(armL); shoulders.add(armR);

            group.userData.isMoving = false;

            if (role === 'BAT') {
                const batGroup = new THREE.Group();
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.05), new THREE.MeshStandardMaterial({ color: 0xccaa88 })); blade.position.y = -0.4;
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.3), new THREE.MeshStandardMaterial({ color: 0x000000 })); handle.position.y = 0.15;
                batGroup.add(blade); batGroup.add(handle); shoulders.add(batGroup);
                
                group.userData.isLeft = Math.random() > 0.5;
                if(group.userData.isLeft) { 
                    batGroup.position.set(-0.2, -0.4, 0.4); batGroup.rotation.x = -0.3; 
                    shoulders.rotation.y = 1.5; head.rotation.y = -1.5; 
                } else { 
                    batGroup.position.set(0.2, -0.4, 0.4); batGroup.rotation.x = -0.3; 
                    shoulders.rotation.y = -1.5; head.rotation.y = 1.5; 
                }
                group.userData.bat = batGroup;
            } else if (role === 'BOWL') { shoulders.rotation.x = 0; group.userData.runStart = -25; } 
            else if (role === 'KEEP') { shoulders.rotation.x = -0.5; group.position.y -= 0.15; }

            allPlayers.push(group); return group;
        }

        function startGame() {
            clearTimeout(deliveryTimer); score = 0; wickets = 0; balls = 0; overs = 0; currentOverLog = [];
            if (innings === 1) target = 0; isBallInPlay = false;
            allPlayers.forEach(p => { gsap.killTweensOf(p.position); gsap.killTweensOf(p.userData.shoulders.rotation); scene.remove(p); });
            allPlayers = []; fielders = [];

            bowler = createPlayer(bowlingTeamStr, 'BOWL'); scene.add(bowler);
            
            striker = createPlayer(battingTeamStr, 'BAT'); striker.position.set(0, 0, 10); scene.add(striker);
            nonStriker = createPlayer(battingTeamStr, 'BAT'); nonStriker.position.set(1.5, 0, -10); nonStriker.rotation.y = Math.PI; scene.add(nonStriker);

            keeper = createPlayer(bowlingTeamStr, 'KEEP'); keeper.position.set(0, 0, 13); scene.add(keeper);

            const angles = [0.8, 2.3, 3.9, 5.5]; 
            angles.forEach(ang => {
                const f = createPlayer(bowlingTeamStr, 'FIELD');
                f.position.set(Math.cos(ang)*(BOUNDARY_RADIUS-10), 0, Math.sin(ang)*(BOUNDARY_RADIUS-10)); f.lookAt(0,0,0);
                scene.add(f); fielders.push(f);
            });

            updateScoreboard(); showStatus(innings === 1 ? "MATCH START" : "2ND INNINGS");
            resetCameraStatic(); deliveryTimer = setTimeout(deliverBall, 3000);
        }

        function deliverBall() {
            if(isBallInPlay || wickets >= MAX_WICKETS || overs >= TOTAL_OVERS) return;
            isBallInPlay = true; camState = 'RUNUP';
            
            bowler.position.z = bowler.userData.runStart; 
            bowler.position.x = 0.6; // Side Bowling Fix

            const tl = gsap.timeline({ onComplete: releaseBall });
            tl.to(bowler.position, { z: -10, duration: 1.2, ease: 'power1.in', onUpdate: () => bowler.userData.isMoving = true });
            tl.to(bowler.position, { z: -8.5, y: 1, duration: 0.15, onStart: () => { bowler.userData.isMoving = false; bowler.userData.shoulders.rotation.x = 3.14; } });
            tl.to(bowler.position, { z: -8, y: 0, duration: 0.1 });
        }

        function releaseBall() {
            camState = 'STATIC'; bowler.userData.shoulders.rotation.x = 0;
            ball.visible = true; ballShadow.visible = true;
            ball.position.set(0.5, 2.2, -8.5);
            playSound('BOWL'); // Call audio
            
            let targetX = (Math.random()-0.5)*1.5; 
            let isWide = false;
            if (Math.random() < 0.12) {
                isWide = true;
                if(striker.userData.isLeft) targetX = Math.random()>0.5 ? 2.5 : -2.5; 
                else targetX = Math.random()>0.5 ? 2.5 : -2.5; 
            }
            
            gsap.to(ball.position, { z: 10, x: targetX, duration: 0.5, ease: 'linear' });
            gsap.to(ball.position, { y: 0, duration: 0.25, ease: 'power1.in' }).then(() => gsap.to(ball.position, { y: 1, duration: 0.25, ease: 'power1.out' }));

            setTimeout(() => { handleShot(targetX, isWide); }, 500);
        }

        function celebrateWicket() { 
            playSound('cheer');
            [bowler, keeper].forEach(p => { if(!p) return; gsap.to(p.position, { y: 1.5, duration: 0.3, yoyo: true, repeat: 5 }); gsap.to(p.userData.shoulders.rotation, { x: 3.14, duration: 0.3, yoyo: true, repeat: 5 }); }); 
        }
        function celebrateWin(winner) { 
            playSound('cheer');
            let team = winner === battingTeamStr ? [striker, nonStriker] : [bowler, keeper, ...fielders]; team.forEach(p => { if(!p) return; gsap.to(p.position, { y: 1.5, duration: 0.4, yoyo: true, repeat: -1 }); gsap.to(p.userData.shoulders.rotation, { x: 3.14, duration: 0.4, yoyo: true, repeat: -1 }); }); 
        }

        function handleShot(bx, isWide) {
            camState = 'FOLLOW';

            if (isWide) {
                showStatus("WIDE"); score += 1; gsap.to(ball.position, { z: 15, x: bx*1.5, y: 0, duration: 0.5 });
                logBall('WD'); updateScoreboard(); setTimeout(() => finishDelivery(false), 1500); return;
            }

            const bat = striker.userData.bat; gsap.to(bat.rotation, { x: -2.5, duration: 0.1, yoyo: true, repeat: 1 });

            // MORE 4s AND 6s, LESS CATCH, LESS DOT BALLS
            const rand = Math.random(); let runs = 0; let shotType = '';
            
            if(rand < 0.05) { shotType = 'BOWLED'; }        // 5%
            else if(rand < 0.15) { shotType = 'CAUGHT'; }   // 10%
            else if(rand < 0.25) { shotType = 'DOT'; runs = 0; } // 10%
            else if(rand < 0.50) { shotType = 'RUNS'; runs = Math.random()>0.5?1:2; } // 25%
            else if(rand < 0.75) { shotType = 'FOUR'; runs = 4; } // 25%
            else { shotType = 'SIX'; runs = 6; }            // 25%

            const angle = Math.random() * Math.PI * 2; 

            if(shotType === 'BOWLED') {
                playSound('hit');
                wickets++; logBall('W'); showStatus("BOWLED!");
                const s = stumpsBatting.children[1]; gsap.to(s.position, { z: 15, y: 2, duration: 0.5 }); gsap.to(s.rotation, { x: 3, duration: 0.5 });
                gsap.to(ball.position, { z: 14, y: 0.5, duration: 0.3 }); celebrateWicket(); setTimeout(() => finishDelivery(true), 2500);
            } 
            else if(shotType === 'CAUGHT') {
                playSound('hit');
                const f = fielders[Math.floor(Math.random() * fielders.length)];
                gsap.to(ball.position, { x: f.position.x, z: f.position.z, duration: 1.5, ease: 'linear', onUpdate: function() { const p = this.progress(); if(p < 1) ball.position.y = Math.sin(p * Math.PI) * 15; }, onComplete: () => { 
                    // Show status ONLY AFTER ball is caught
                    wickets++; logBall('W'); showStatus("CATCH OUT!");
                    celebrateWicket(); setTimeout(() => finishDelivery(true), 2500); 
                } });
            }
            else if (shotType === 'DOT') {
                playSound('hit');
                gsap.to(ball.position, { z: 15, x: bx + Math.random(), y:0, duration: 0.5 }); logBall('0'); updateScoreboard(); setTimeout(() => finishDelivery(true), 1500);
            }
            else if (shotType === 'FOUR') {
                playSound('hit');
                // Crosses Boundary Rope clearly (RADIUS + 6)
                const destX = Math.sin(angle) * (BOUNDARY_RADIUS+6); const destZ = Math.cos(angle) * (BOUNDARY_RADIUS+6) + 10;
                gsap.to(ball.position, { x: destX, z: destZ, y: 0, duration: 1.5, ease: 'power1.out', onComplete: () => {
                    // Show status ONLY AFTER it hits boundary
                    playSound('cheer'); showStatus("FOUR!"); score += 4; logBall('4'); updateScoreboard(); setTimeout(() => finishDelivery(true), 2500);
                }});
            }
            else if (shotType === 'SIX') {
                playSound('hit');
                const destX = Math.sin(angle) * (BOUNDARY_RADIUS+18); const destZ = Math.cos(angle) * (BOUNDARY_RADIUS+18) + 10;
                gsap.to(ball.position, { x: destX, z: destZ, duration: 2, ease: 'linear', onUpdate: function() { const p = this.progress(); if(p < 1) ball.position.y = Math.sin(p * Math.PI) * 25; }, onComplete: () => {
                    // Show status ONLY AFTER it lands
                    playSound('cheer'); showStatus("SIX!"); score += 6; logBall('6'); updateScoreboard(); setTimeout(() => finishDelivery(true), 3000);
                }});
                gsap.to(ball.position, { y: 2, duration: 0.4, delay: 2, yoyo: true, repeat: 1 }); 
            }
            else if (shotType === 'RUNS') {
                playSound('hit');
                const destX = Math.sin(angle) * (runs===2?45:25); const destZ = Math.cos(angle) * (runs===2?45:25) + 10;
                const timeToChase = runs === 2 ? 3.0 : 1.8; 
                gsap.to(ball.position, { x: destX, z: destZ, y: 0, duration: timeToChase, ease: 'power1.out' });

                striker.userData.isMoving = true; nonStriker.userData.isMoving = true;
                const runDur = timeToChase / (runs===2?2:1) - 0.1; 
                gsap.to(striker.position, { z: -10, duration: runDur, yoyo: runs===2, repeat: runs===2?1:0, ease: 'linear', onComplete:()=>striker.userData.isMoving=false });
                gsap.to(nonStriker.position, { z: 10, duration: runDur, yoyo: runs===2, repeat: runs===2?1:0, ease: 'linear', onComplete:()=>nonStriker.userData.isMoving=false });

                let closestF = fielders[0], minDist = 999;
                fielders.forEach(f => { const d = Math.hypot(f.position.x - destX, f.position.z - destZ); if(d < minDist) { minDist = d; closestF = f; } });
                closestF.lookAt(destX, 0, destZ);

                gsap.to(closestF.position, { x: destX, z: destZ, duration: timeToChase, onUpdate: ()=>closestF.userData.isMoving=true, onComplete: () => {
                    closestF.userData.isMoving = false; closestF.lookAt(0, 0, 10);
                    
                    const isRunOut = Math.random() < 0.10;
                    if(isRunOut) {
                        wickets++; logBall('W'); showStatus("RUN OUT!"); gsap.to(ball.position, { x: 0, z: 10, y: 0.5, duration: 0.5 }); celebrateWicket();
                    } else {
                        score += runs; logBall(runs); 
                        if(runs === 1) { const temp = striker; striker = nonStriker; nonStriker = temp; }
                        gsap.to(ball.position, { x: 0, z: 13, y: 1, duration: 0.6 }); 
                    }
                    updateScoreboard(); setTimeout(() => finishDelivery(true), 1500);
                }});
            }
        }

        function finishDelivery(countBall) {
            if(countBall) { balls++; if(balls === 6) { balls = 0; overs++; currentOverLog = []; } }
            updateScoreboard();
            
            if(innings === 2 && score > target) { endMatch(battingTeamStr); return; }
            if(wickets >= MAX_WICKETS || overs >= TOTAL_OVERS) {
                if(innings === 1) {
                    innings = 2; target = score; score = 0; wickets = 0; balls = 0; overs = 0; currentOverLog = [];
                    let temp = battingTeamStr; battingTeamStr = bowlingTeamStr; bowlingTeamStr = temp;
                    showStatus("INNINGS BREAK"); setTimeout(startGame, 4000);
                } else {
                    if(score > target) endMatch(battingTeamStr); else if(score < target) endMatch(bowlingTeamStr); else endMatch("DRAW");
                }
                return;
            }

            ball.visible = false; ballShadow.visible = false;
            stumpsBatting.children[1].position.set(0, 0.47, 0); stumpsBatting.children[1].rotation.set(0, 0, 0);
            
            striker.position.set(0, 0, 10); striker.rotation.y = 0;
            nonStriker.position.set(1.5, 0, -10); nonStriker.rotation.y = Math.PI;
            
            resetCameraStatic();
            fielders.forEach(f => { if(Math.abs(f.position.x) < 20 && Math.abs(f.position.z) < 20) { f.position.set(Math.cos(Math.random()*6)*50, 0, Math.sin(Math.random()*6)*50); f.lookAt(0,0,0); } });
            isBallInPlay = false; deliveryTimer = setTimeout(deliverBall, 1500); 
        }

        function endMatch(winner) {
            isBallInPlay = true; let finalWinner = winner;
            if (winner === "DRAW") { finalWinner = Math.random() > 0.5 ? battingTeamStr : bowlingTeamStr; showStatus(`TIED! ${finalWinner} wins Super Over!`); } 
            else { showStatus(`${finalWinner} WINS!`); }
            celebrateWin(finalWinner); 
            setTimeout(() => {
                if(gameMode === 'TOURNAMENT') { tournamentBracket[currentTournMatchIdx].winner = finalWinner; renderTournamentMenu(); } 
                else { renderMainMenu(); }
            }, 5000);
        }

        function updateScoreboard() {
            document.getElementById('scorecard').innerText = `${battingTeamStr}: ${score}/${wickets} (${overs}.${balls})`;
            document.getElementById('target-info').innerText = innings === 2 ? `TARGET: ${target+1}` : "1st INNINGS";
            document.getElementById('ball-tracker').innerHTML = currentOverLog.map(b => `<div class="ball-bubble ${b==='4'?'b-4':b==='6'?'b-6':b==='W'?'b-w':b==='WD'?'b-wd':''}">${b}</div>`).join('');
        }
        function logBall(val) { currentOverLog.push(val); }
        function showStatus(msg) { const el = document.getElementById('status'); el.innerText = msg; el.style.display = 'block'; gsap.fromTo(el, {scale: 0}, {scale: 1, duration: 0.5, ease: "elastic.out(1, 0.3)"}); setTimeout(() => el.style.display = 'none', 2500); }

        function renderMainMenu() {
            const mc = document.getElementById('menu-container'); mc.classList.remove('hidden');
            mc.innerHTML = `<div class="glass-panel"><div class="menu-title">üèè ULTIMATE CRICKET</div><div class="menu-btn" id="btn-quick">‚ö° QUICK MATCH</div><div class="menu-btn" id="btn-tourn">üèÜ TOURNAMENT</div></div>`;
            document.getElementById('btn-quick').onclick = () => { gameMode = 'QUICK'; renderTeamSelect('PLAYER'); };
            document.getElementById('btn-tourn').onclick = () => { gameMode = 'TOURNAMENT'; tournamentRound = 0; renderTeamSelect('PLAYER'); };
        }

        function renderTeamSelect(step) {
            const mc = document.getElementById('menu-container');
            let html = `<div class="glass-panel"><div class="menu-title">${step === 'PLAYER' ? "YOUR TEAM" : "OPPONENT"}</div><div class="team-grid">`;
            TEAMS.forEach(t => {
                const disabled = (step === 'OPPONENT' && t === playerTeam) ? 'style="opacity:0.3; pointer-events:none"' : '';
                html += `<div class="team-btn" ${disabled} data-team="${t}" style="border-left: 5px solid #${TEAM_COLORS[t].toString(16)}">${t}</div>`;
            });
            html += `</div></div>`; mc.innerHTML = html;
            
            document.querySelectorAll('.team-btn').forEach(b => {
                b.onclick = () => {
                    if(step === 'PLAYER') { playerTeam = b.dataset.team; if(gameMode === 'QUICK') renderTeamSelect('OPPONENT'); else { setupTournamentBracket(); renderTournamentMenu(); } } 
                    else { opponentTeam = b.dataset.team; battingTeamStr = playerTeam; bowlingTeamStr = opponentTeam; isWatchMode = false; mc.classList.add('hidden'); innings = 1; startGame(); }
                };
            });
        }

        function setupTournamentBracket() {
            if(tournamentRound === 0) {
                let pool = TEAMS.filter(t => t !== playerTeam); pool.sort(() => Math.random() - 0.5); pool.unshift(playerTeam); 
                tournamentBracket = []; for(let i=0; i<8; i+=2) tournamentBracket.push({p1: pool[i], p2: pool[i+1], winner: null});
            } else {
                let newBracket = []; for(let i=0; i<tournamentBracket.length; i+=2) newBracket.push({p1: tournamentBracket[i].winner, p2: tournamentBracket[i+1].winner, winner: null});
                tournamentBracket = newBracket;
            }
        }

        function renderTournamentMenu() {
            const mc = document.getElementById('menu-container');
            let html = `<div class="glass-panel"><div class="menu-title">${["QUARTER FINALS", "SEMI FINALS", "FINAL"][tournamentRound]}</div>`;
            let allFinished = true;
            tournamentBracket.forEach((m, idx) => {
                const isMyMatch = m.p1 === playerTeam || m.p2 === playerTeam;
                if (!m.winner) allFinished = false;
                html += `<div class="bracket-row ${isMyMatch ? 'my-match' : ''}"><span style="font-weight:bold">${m.p1} vs ${m.p2}</span>`;
                if (m.winner) html += `<span style="color:#4CAF50; font-weight:bold">${m.winner} Won</span>`;
                else if (isMyMatch) html += `<button class="action-btn btn-play tourn-btn" data-idx="${idx}" data-action="PLAY">PLAY</button>`;
                else html += `<div><button class="action-btn btn-watch tourn-btn" data-idx="${idx}" data-action="WATCH">WATCH</button><button class="action-btn btn-sim tourn-btn" data-idx="${idx}" data-action="SIM">SIM</button></div>`;
                html += `</div>`;
            });
            if (allFinished) html += `<button id="next-btn" class="menu-btn" ${tournamentRound === 2 ? 'style="background:gold; color:black;"' : ''}>${tournamentRound === 2 ? 'üèÜ TOURNAMENT COMPLETE üèÜ' : 'ADVANCE TO NEXT ROUND'}</button>`; 
            html += `</div>`; mc.innerHTML = html; mc.classList.remove('hidden');
            
            document.querySelectorAll('.tourn-btn').forEach(btn => {
                btn.onclick = () => {
                    const idx = btn.dataset.idx, action = btn.dataset.action, match = tournamentBracket[idx];
                    if (action === 'SIM') { match.winner = Math.random() > 0.5 ? match.p1 : match.p2; renderTournamentMenu(); } 
                    else { battingTeamStr = match.p1; bowlingTeamStr = match.p2; isWatchMode = (action === 'WATCH'); currentTournMatchIdx = idx; mc.classList.add('hidden'); innings = 1; startGame(); }
                };
            });
            const nextBtn = document.getElementById('next-btn');
            if (nextBtn) { nextBtn.onclick = () => { if (tournamentRound === 2) renderMainMenu(); else { tournamentRound++; setupTournamentBracket(); renderTournamentMenu(); } }; }
        }

        function animate() {
            requestAnimationFrame(animate); renderer.render(scene, camera);
            allPlayers.forEach(p => {
                if(p.userData.isMoving) { p.userData.legs[0].position.z = Math.sin(Date.now()*0.02)*0.4; p.userData.legs[1].position.z = -Math.sin(Date.now()*0.02)*0.4; } 
                else { p.userData.legs[0].position.z = 0; p.userData.legs[1].position.z = 0; }
            });

            if (camState === 'RUNUP' && bowler) { gsap.to(camera.position, { x: bowler.position.x*0.5, y: 6, z: bowler.position.z-6, duration: 0.1 }); controls.target.set(0, 1, 10); } 
            else if (camState === 'FOLLOW' && ball.visible) controls.target.lerp(ball.position, 0.1);

            controls.update();
            if(ball.visible) { ballShadow.position.x = ball.position.x; ballShadow.position.z = ball.position.z; ballShadow.scale.setScalar(Math.max(0, 1 - ball.position.y/25)); }
        }

        initScene(); renderMainMenu();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
